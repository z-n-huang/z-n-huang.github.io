<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>UD editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- jQuery (no SRI to avoid integrity errors) -->
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 20px;
      line-height: 1.5;
    }
    .controls {
      margin: 10px 0;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    textarea {
      width: 100%;
      height: 40vh;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 6px;
      white-space: pre;
    }
    button {
      padding: 8px 14px;
      border: 1px solid #888;
      border-radius: 6px;
      background: #f7f7f7;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .status {
      margin-top: 8px;
      color: #555;
      font-size: 0.95em;
    }
    .file-info {
      font-size: 0.95em;
      color: #333;
    }

    /* Two-row POS grid (tokens row + UPOS row) */
    .pos-grid-wrapper {
      margin-top: 16px;
      overflow-x: auto;
    }
    .pos-grid {
      border-collapse: collapse;
      width: auto;
      table-layout: auto;
    }
    .pos-grid td {
      border: 1px solid #ddd;
      padding: 10px 12px;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 120ms ease;
    }
	/* Index row (1..n) above tokens */
	.pos-grid .index-cell {
	  color: #777;
	  font-size: 13px;
	  font-weight: 600;
	  background: #fafafa;
	  border: 1px solid #ddd;      /* match grid borders */
	  pointer-events: none;        /* not clickable */
	}
    /* Color rules for POS (apply to both token and POS cells) */
    .upos-verb { color: #d32f2f; font-weight: 700; }   /* VERB red */
    .upos-blue { color: #1e4fa3; font-weight: 700; }   /* NOUN/PROPN/PRON blue */
    .upos-intj { color: #d08a00; font-weight: 700; }   /* INTJ orange */
    .upos-black { color: #111; font-weight: 700; }     /* ADV/AUX/copulas black */
    .upos-grey { color: #444444; }                     /* others greyed (still legible) */

    /* Selection highlight for the clicked token’s cells */
    .selected {
      background: #e6f0ff;
      outline: 2px solid #84a9ff;
      outline-offset: -2px;
    }
	/* For summaries */
	.dep-summary {
	  margin-top: 12px;
	  font-size: 14px;
	}
	.dep-summary ul {
	  margin: 6px 0 6px 20px;
	}
	.dep-summary li {
	  margin: 2px 0;
	}
	.dep-summary .verb-head {
	  font-weight: 600;
	}
	.dep-summary .nil {
	  color: #9aa0a6;   /* greyed out NIL */
	}
	/* Collapsible Help panel */
	.help-panel {
	  border: 1px solid #ddd;
	  border-radius: 6px;
	  padding: 10px 12px;
	  background: #fafafa;
	  max-height: 40vh;
	  overflow: auto;
	  margin-top: 8px;
	}
	.hidden { display: none; }

	/* Default: hide UD tree at load so table is emphasized */
	#treeBox { display: none; }
	/* Highlight the current anchor w1 during Guided Edit (batch) */
	.guided-anchor {
	  outline: 2px solid #ff9800;
	  outline-offset: -2px;
	  background: #fff7e6;
	}
  </style>
</head>
<body>
  
  <!-- Help tab toggle -->
<div class="controls">
  <button id="helpToggleBtn">Show Help</button>
  <button id="treeToggleBtn">Show UD Tree</button>
</div>

<!-- Collapsible Help panel -->
<div id="helpPanel" class="help-panel hidden">
  <h3>Keyboard shortcuts and behaviour</h3>
  <ul>
    <li>Navigation
      <ul>
        <li>&lt; (Shift + ,): Previous tree (saves current edits)</li>
        <li>&gt; (Shift + .): Next tree (saves current edits)</li>
        <li>Shift + S: Export all edited trees as .conllu</li>
      </ul>
    </li>
    <li>Selecting tokens
      <ul>
        <li>Click any word or POS cell to select it.</li>
        <li>Selected token is highlighted; in Mass Edit mode, the anchor (head word) stays highlighted.</li>
      </ul>
    </li>
    <li>Single-word edits (choose a word, press a key)
      <ul>
        <li>r: Make the selected word w1 the root of the entire sentence. Add a DEPREL where w1 is the head and the old root the dependent.</li>
        <li>v / n / a / i: Set POS = VERB / NOUN / ADV / INTJ</li>
      </ul>
    </li>
    <li>Two-word relations: click on w1/head, press a key, then click on w2/dependent
      <ul>
        <li>Press b: Set w2 as w1’s subject (nsubj; csubj if w2 is a VERB). Any existing subject of w1 becomes fmrsubj.</li>
        <li>Press c: Set w2 as w1’s complement:
          <ul>
            <li>dobj if w2 is a NOUN</li>
            <li>xcomp if w2 is a non‑finite VERB (VerbForm=Inf or “to”)</li>
            <li>CCOMP if w2 is a finite VERB</li>
          </ul>
        </li>
        <li>Press p: w2 is in a discourse deprel with w1 (e.g. sentence-final particle)</li>
        <li>Press t: w2 is in a dislocated deprel with w1 (e.g. topics)</li>
        <li>Press x: w2 is in a parataxis deprel with w1 (e.g. w2 is actually the main verb of a second sentence)</li>
      </ul>
    </li>
	<li>Guided Edit mode: Suppose we have a set of trees, and we want to just focus on fixing up a certain DEPREL (e.g. subjects). This mode will automatically bring you through all existing tokens of that DEPREL; you can confirm or make changes to the dependent.
		<ul>
			<li>Press g: Enter Guided Edit mode.</li>
			<li>Press b/c/p/t/x (the DEPREL to focus on). Suppose you press "b" - subject. The webpage will automatically highlight one head (e.g. the root word), and mention what word is its subject. Press enter to confirm, or if the current word is wrong, click on the word that is actually the subject.</li>
			<li>Once you press enter or click on another word, the webpage will highlight that next word that should have a subject, e.g. another verb in the same sentence.
			<li>If there are no more words with that need subjects in the sentence, the webpage will automatically progress to the next sentence and repeat the process, until there are no more sentences.</li>
			<li>
	</li>
    <li>Mass Edit mode: Suppose we have a word w1. Mass Edit lets us identify the words that take w1 as their head and the corresponding DEPRELs.
      <ul>
        <li>Press m: Enter Mass Edit (status shows “active”).</li>
        <li>Click w1 - this is now the head word. Press one of b/c/p/t/x (the DEPREL), then click w2 to apply. Now w2 is in this DEPREL relation with w1. Let's say you click on one word w1, and then press b (subject). Click on the word that is w1's subject. Then you press c (complement) and click on the word that is w1's object. Then you press p (particle) and click on the particle that are linked to w1. Press p again to link another particle to w1.</li>
		<li>Repeat with new letters to link w1 to w3, w4, etc.</li>
        <li>Esc (once): Clear pending actions but stay in Mass Edit. Click a new w1 to continue.</li>
        <li>Esc (again while idle): Exit Mass Edit.</li>
      </ul>
    </li>
    <li>Split / Merge (token boundary edits)
      <ul>
        <li>- (hyphen): Split selected token. A one-line input appears; type space-separated words (at least two words). Each becomes a new token with POS=VERB.</li>
        <li>+ (plus): Merge with an adjacent token (click it). Forms are concatenated (no space), POS=UNK. Non‑adjacent clicks are rejected.</li>
      </ul>
    </li>
    <li>Display
      <ul>
        <li>Top row shows token positions 1...n; middle row shows words; bottom row shows UPOS.</li>
        <li>Colors: VERB=red; NOUN/PROPN/PRON=blue; INTJ=orange; ADV/AUX/copulas=black; others=grey.</li>
      </ul>
    </li>
  </ul>
</div>

  <div class="controls">
    <input type="file" id="fileInput" accept=".conllu,.txt" />
    <span class="file-info" id="fileInfo"></span>
  </div>

  <div class="controls">
    <button id="prevBtn" disabled>Prev</button>
    <button id="nextBtn" disabled>Next</button>
    <span class="status" id="status"></span>
  </div>
  <div class="controls">
    <input type="text" id="splitInput" placeholder="Type words to split (space-separated)" style="display:none; width: 320px;">
    <button id="splitApplyBtn" style="display:none;">Apply split</button>
  </div>

  <textarea id="treeBox" placeholder="Load a CoNLL-U file to begin..." disabled></textarea>

  <div class="pos-grid-wrapper">
    <table id="posGrid" class="pos-grid" aria-label="Token and POS grid"></table>
	<div id="depSummary" class="dep-summary"></div>
  </div>

  <script>
    // Global state
    let trees = [];            // Array of strings, each a single tree block
    let currentIndex = -1;     // Current tree index
    let debounceTimer = null;
    let originalFileName = 'trees.conllu';
    let selectedTokenId = null; // ID string of the selected token (column 1)
	// Two-step action state
	let pendingTwoStep = null;   // one of: 'b','c','p','t','x'
	let anchorTokenId = null;    // token A (first click before the key, or currently selected)
	// String operations:
	// Split/Merge state
	let pendingMerge = null;    // when '+', holds anchor token A's id
	let splitInputActive = false;
	// Mass edit mode
	let massEditActive  = false;   // true when in mass-edit mode
	let massAnchorId    = null;    // w1 (the current anchor token)
	let massPendingKind = null;    // one of 'b','c','p','t','x' awaiting a target click
	// Alternative Mass edit mode
	let massAwaitKey   = false;    // true when w2 is chosen and we’re waiting for a letter
	let massPendingW2  = null;     // stores w2’s id while waiting for a key
	// Guided Edit (batch) mode state
	let guidedBatchActive = false;   // true while in batch mode
	let guidedOp = null;             // one of 'b','c','p','t','x' (relation being annotated)
	let guidedW1List = [];           // array of token IDs for w1 (tokens with deprel root/xcomp/ccomp/parataxis)
	let guidedW1Idx = -1;            // index into guidedW1List for current w1
	let guidedCandidateId = null;    // proposed existing dependent for current w1 (nullable)
	let guidedMultiSelect = false;   // true for c/p/t/x (click many, finish with Escape); false for b
	
	// Guided (interactive panel) optional state (used by panel buttons)
	let guidedEditActive  = false;
	//let guidedAnchorId    = null;
	//let guidedPendingKind = null;
	//let guidedAwaitKey    = false;
	//let guidedPendingW2   = null;
	
    // Split CoNLL-U text into trees by blank lines
    function parseConllu(text) {
      const normalized = (text || '').replace(/\r\n/g, '\n');
      const trimmed = normalized.trim();
      if (!trimmed) return [];
      return trimmed.split(/\n\s*\n+/);
    }

    // Robust column splitter: tabs preferred; fallback to >=2 spaces
    function splitConlluCols(line) {
      if (line.indexOf('\t') !== -1) return line.split('\t');
      return line.trim().split(/ {2,}|\t/);
    }

    // Parse current tree to tokens; keep lineIndex for each token
    function parseTreeToTokens(treeText) {
      const lines = (treeText || '').split('\n');
      const tokens = [];
      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        const line = raw.trimEnd();
        if (!line || line.startsWith('#')) continue;

        const cols = splitConlluCols(line);
        if (cols.length < 10) continue;

        const id = cols[0];
        if (id.includes('-') || id.includes('.')) continue; // skip MWT / empty nodes

        tokens.push({
          lineIndex: i,
          id: cols[0],
          form: cols[1],
          lemma: cols[2],
          upos: cols[3],
          xpos: cols[4],
          feats: cols[5],
          head: cols[6],
          deprel: cols[7],
          deps: cols[8],
          misc: cols[9],
        });
      }
      return tokens;
    }

	// Read all token rows (excluding comments/MWT/empty nodes) as a flat list with full columns
	function readTokenRows() {
	  const lines = (trees[currentIndex] || '').split('\n');
	  const rows = [];
	  for (let i = 0; i < lines.length; i++) {
		const raw = lines[i];
		if (!raw || raw.startsWith('#')) continue;
		const cols = splitConlluCols(raw);
		if (cols.length < 10) continue;
		const id = cols[0];
		if (id.includes('-') || id.includes('.')) continue; // skip multiword/empty
		rows.push({ cols, idx: i }); // store original line index too (not reused on rebuild)
	  }
	  return rows;
	}

	// Rebuild the tree using provided token rows and keeping non-token lines intact.
	// IDs are reassigned sequentially from 1..N. HEADs are remapped accordingly; root (0) preserved.
	// Any references to removed/inserted tokens are redirected per the provided idMap function.
	function rebuildTreeWithTokens(newTokenColsList, redirectMap = new Map()) {
	  const origLines = (trees[currentIndex] || '').split('\n');

	  // Keep comment/non-token lines
	  const preserved = origLines.filter(l => !l || l.startsWith('#') || (splitConlluCols(l)[0] || '').includes('-') || (splitConlluCols(l)[0] || '').includes('.'));

	  // Assign new IDs and build mapping from old order position to new ID
	  const N = newTokenColsList.length;
	  const newLines = [];
	  const newIdByIndex = new Map(); // index in newTokenColsList -> new ID string
	  for (let i = 0; i < N; i++) newIdByIndex.set(i, String(i + 1));

	  // Build map from old token order index to chosen new target ID (used for heads)
	  // redirectMap: optional map oldId -> targetId (e.g., when splitting/merging affects references)
	  const toTargetId = (oldId) => {
		if (!oldId || oldId === '0') return oldId; // root stays 0
		if (redirectMap.has(oldId)) return redirectMap.get(oldId);
		// If oldId was a sequential number, try to preserve relative position:
		// We don't know the old index here, so rely on explicit redirectMap for affected ids.
		return oldId; // fallback (unchanged) if we didn't touch it
	  };

	  // Write token lines with remapped HEADs and fresh IDs
	  for (let i = 0; i < N; i++) {
		const cols = newTokenColsList[i].slice(0, 10);
		// Assign new sequential ID
		cols[0] = newIdByIndex.get(i);
		// Remap head (if numeric)
		const h = cols[6];
		cols[6] = /^-?\d+$/.test(h) ? toTargetId(h) : h;
		newLines.push(cols.join('\t'));
	  }

	  // Compose final tree: keep comments first, then tokens (simple policy)
	  const final = [
		...origLines.filter(l => l.startsWith('#')),
		...newLines
	  ].join('\n');

	  trees[currentIndex] = final;
	  $('#treeBox').val(final);
	  renderPosGrid();
	  renderDependencySummary && renderDependencySummary();
	}
	
	
	function applySplitOnSelected() {
	  if (!selectedTokenId || currentIndex < 0) return;
	  const input = ($('#splitInput').val() || '').trim();
	  if (!input || !/\s+/.test(input)) {
		$('#status').text('There must be at least two words here');
		return;
	  }
	  const pieces = input.split(/\s+/).filter(w => w.length);
	  if (pieces.length < 2) {
		$('#status').text('There must be at least two words here');
		return;
	  }

	  const rows = readTokenRows();
	  const pos = rows.findIndex(r => r.cols[0] === selectedTokenId);
	  if (pos < 0) return;

	  const selected = rows[pos];
	  const oldHead = selected.cols[6];
	  const oldDeprel = selected.cols[7];

	  // Build new token cols list:
	  // - All tokens before selected unchanged
	  // - Replace selected by N new tokens, each UPOS=VERB, FORM=piece
	  //   First piece inherits HEAD/DEPREL from the original selected token
	  //   Remaining pieces depend on the first piece (head = first piece id, deprel=dep)
	  // - All tokens after selected unchanged
	  const newColsList = [];
	  for (let i = 0; i < pos; i++) newColsList.push(rows[i].cols.slice(0, 10));

	  // Placeholder IDs during build (we will assign real IDs in rebuild)
	  const firstNewPlaceholderId = 'FIRST_NEW_ID';

	  for (let j = 0; j < pieces.length; j++) {
		const piece = pieces[j];
		const cols = Array(10).fill('_');
		cols[0] = 'X';                 // temp
		cols[1] = piece;               // FORM
		cols[2] = piece.toLowerCase(); // LEMMA (simple)
		cols[3] = 'VERB';              // UPOS
		cols[4] = '_';                 // XPOS
		cols[5] = '_';                 // FEATS
		// HEAD/DEPREL
		if (j === 0) {
		  cols[6] = oldHead;           // inherit original head
		  cols[7] = oldDeprel;         // inherit original deprel
		} else {
		  cols[6] = firstNewPlaceholderId;
		  cols[7] = 'dep';
		}
		cols[8] = '_';                 // DEPS
		cols[9] = '_';                 // MISC
		newColsList.push(cols);
	  }

	  for (let i = pos + 1; i < rows.length; i++) newColsList.push(rows[i].cols.slice(0, 10));

	  // Redirect heads:
	  // - Any token that had head = selectedTokenId should now point to the first new token.
	  // - Any piece after the first that had head FIRST_NEW_ID will be remapped to the new real id of the first piece.
	  const redirect = new Map();
	  redirect.set(selectedTokenId, 'FIRST_NEW_REAL'); // will be replaced in rebuild

	  // Rebuild once to assign real IDs, then fix placeholder references
	  rebuildTreeWithTokens(newColsList, redirect);

	  // After rebuild, we know the real ID of the first new piece (it's the current selected token's position + 1)
	  const tokens = parseTreeToTokens(trees[currentIndex]);
	  const firstNewId = String(pos + 1); // because IDs are reassigned from 1..N in order

	  // Replace placeholder strings
	  let finalText = $('#treeBox').val();
	  finalText = finalText.replace(/\bFIRST_NEW_ID\b/g, firstNewId)
						   .replace(/\bFIRST_NEW_REAL\b/g, firstNewId);
	  trees[currentIndex] = finalText;
	  $('#treeBox').val(finalText);
	  renderPosGrid();
	  renderDependencySummary && renderDependencySummary();
	  hideSplitUI();
	  $('#status').text(`Split token ${selectedTokenId} into ${pieces.length} parts`);
	}
	
	function startMerge() {
	  if (!selectedTokenId) {
		$('#status').text('Select token A first, then press + and click adjacent token B.');
		return;
	  }
	  pendingMerge = selectedTokenId;
	  $('#status').text(`Pending merge: A=${pendingMerge}. Click adjacent token B.`);
	}

	function applyMergeWith(targetId) {
	  if (!pendingMerge || !targetId) return;

	  const rows = readTokenRows();
	  const aPos = rows.findIndex(r => r.cols[0] === pendingMerge);
	  const bPos = rows.findIndex(r => r.cols[0] === targetId);
	  if (aPos < 0 || bPos < 0) return;

	  // Must be adjacent in order
	  if (Math.abs(aPos - bPos) !== 1) {
		$('#status').text('Adjacent words only');
		pendingMerge = null;
		return;
	  }

	  const firstPos = Math.min(aPos, bPos);
	  const secondPos = Math.max(aPos, bPos);

	  const A = rows[firstPos].cols.slice(0, 10);
	  const B = rows[secondPos].cols.slice(0, 10);

	  // Concatenate FORM in original order; UPOS=UNK; keep HEAD/DEPREL of A; other cols as A except LEMMA from combined lowercased
	  const mergedForm = `${A[1]}${B[1]}`; // no space per your spec
	  const mergedCols = A.slice(0, 10);
	  mergedCols[1] = mergedForm;
	  mergedCols[2] = mergedForm.toLowerCase();
	  mergedCols[3] = 'UNK';

	  // Build new list: before firstPos unchanged, then merged, then skip secondPos, then rest
	  const newColsList = [];
	  for (let i = 0; i < firstPos; i++) newColsList.push(rows[i].cols.slice(0, 10));
	  newColsList.push(mergedCols);
	  for (let i = secondPos + 1; i < rows.length; i++) newColsList.push(rows[i].cols.slice(0, 10));

	  // Redirect heads:
	  // - Any token that had head = B's old id should now point to A's old id (which becomes merged line)
	  const redirect = new Map();
	  redirect.set(B[0], A[0]);

	  rebuildTreeWithTokens(newColsList, redirect);

	  pendingMerge = null;
	  selectedTokenId = String(firstPos + 1); // merged token's new id
	  renderPosGrid();
	  renderDependencySummary && renderDependencySummary();
	  $('#status').text(`Merged tokens into id ${selectedTokenId}`);
	}

    // Decide color class based on UPOS and DEPREL
    // - VERB => red; NOUN/PROPN/PRON => blue; INTJ => orange
    // - ADV/AUX and tokens with deprel=cop => black
    // - Others => grey
    function uposClass(token) {
      const up = (token.upos || '').toUpperCase();
      const dep = (token.deprel || '').toLowerCase();
      if (dep === 'cop') return 'upos-black';
      if (up === 'VERB') return 'upos-verb';
      if (up === 'NOUN' || up === 'PROPN' || up === 'PRON') return 'upos-blue';
      if (up === 'INTJ') return 'upos-intj';
      if (up === 'ADV' || up === 'AUX') return 'upos-black';
      return 'upos-grey';
    }

    function renderPosGrid() {
  const table = $('#posGrid');
  table.empty();
  if (currentIndex < 0 || currentIndex >= trees.length) return;

  const tokens = parseTreeToTokens(trees[currentIndex]);

  const $indexRow  = $('<tr/>');
  const $tokensRow = $('<tr/>');
  const $uposRow   = $('<tr/>');

  const guidedW1 = typeof currentGuidedW1Id === 'function' ? currentGuidedW1Id() : null;

  for (let i = 0; i < tokens.length; i++) {
    const tok = tokens[i];
    const klass = uposClass(tok);

    const classes = [klass];
    // guided batch anchor highlight
    if (guidedBatchActive && guidedW1 && tok.id === guidedW1) classes.push('guided-anchor');
    // else normal selection
    else if (!guidedBatchActive && selectedTokenId && tok.id === selectedTokenId) classes.push('selected');

    $indexRow.append($('<td/>', { class: 'index-cell', text: String(i + 1) }));
    $tokensRow.append($('<td/>', { 'data-token-id': tok.id, class: classes.join(' '), text: tok.form || '' }));
    $uposRow.append($('<td/>', { 'data-token-id': tok.id, class: classes.join(' '), text: (tok.upos || '').toUpperCase() }));
  }

  table.append($indexRow, $tokensRow, $uposRow);

  // Delegated click handler — paste this EXACTLY here
  $('#posGrid')
    .off('click', 'td[data-token-id]')
    .on('click', 'td[data-token-id]', function(e) {
      const id = $(this).attr('data-token-id');
      if (!id) return;

      // Guided Edit (batch) branch
      if (guidedBatchActive) {
        e.preventDefault();
        if (!guidedOp) {
          $('#status').text('Guided: press b/c/p/t/x to choose relation, then click target(s).');
          return;
        }
        const w1Id = currentGuidedW1Id();
        if (!w1Id) {
          $('#status').text('Guided: no current w1. Press b/c/p/t/x to (re)start.');
          return;
        }
        performTwoStepAction(guidedOp, w1Id, id);
        if (guidedOp === 'b') {
          guidedCandidateId = null;
          advanceGuidedToNextW1();
        } else {
          $('#status').text(`Guided: linked ${id} to ${w1Id} as '${guidedOp}'. Click more or press Esc when done.`);
        }
        renderPosGrid();
        if (typeof renderDependencySummary === 'function') renderDependencySummary();
        return;
      }

      // Mass edit
      if (massEditActive) {
        e.preventDefault();
        if (massPendingKind && massAnchorId) {
          performTwoStepAction(massPendingKind, massAnchorId, id);
          massPendingKind = null;
          selectedTokenId = massAnchorId;
          renderPosGrid();
          $('#status').text(`Mass edit: applied ${massPendingKind || ''} ${massAnchorId} -> ${id}.`);
          return;
        }
        massAnchorId    = id;
        selectedTokenId = id;
        renderPosGrid();
        $('#status').text(`Mass edit: w1=${id} selected. Press b/c/p/t/x, then click w2.`);
        return;
      }

      // Pending merge
      if (pendingMerge) { applyMergeWith(id); return; }

      // Two-step (non-mass)
      if (pendingTwoStep && anchorTokenId) {
        const kind = pendingTwoStep;
        pendingTwoStep = null;
        selectedTokenId = anchorTokenId;
        performTwoStepAction(kind, anchorTokenId, id);
        renderPosGrid();
        $('#status').text(`Applied '${kind}' from ${anchorTokenId} to ${id}`);
        return;
      }

      // Normal selection
      selectedTokenId = id;
      anchorTokenId   = id;
      renderPosGrid();
      $('#status').text(`Selected token ${id}`);
    });

  // Refresh summary if you use it
  if (typeof renderDependencySummary === 'function') renderDependencySummary();
}

    // Render the current tree into the textarea and grid
    function renderCurrentTree() {
      const box = $('#treeBox');
      const status = $('#status');

      if (currentIndex < 0 || currentIndex >= trees.length) {
        box.val('');
        box.prop('disabled', true);
        status.text('No tree loaded.');
        $('#prevBtn').prop('disabled', true);
        $('#nextBtn').prop('disabled', true);
        $('#posGrid').empty();
        selectedTokenId = null;
        return;
      }

      box.val(trees[currentIndex]);
      box.prop('disabled', false);
      status.text(`Tree ${currentIndex + 1} of ${trees.length}`);

      $('#prevBtn').prop('disabled', currentIndex <= 0);
      $('#nextBtn').prop('disabled', currentIndex >= trees.length - 1);

      renderPosGrid();
	  renderDependencySummary();
    }

    // Save the current textbox content back into the trees array
    function saveCurrentEdits() {
      if (currentIndex >= 0 && currentIndex < trees.length) {
        const edited = $('#treeBox').val();
        trees[currentIndex] = edited;
      }
    }

    // Update a single token line by token ID, using an updater on its 10 columns
    function updateTokenById(tokenId, updater) {
      if (currentIndex < 0) return false;
      const treeText = trees[currentIndex] || '';
      const lines = treeText.split('\n');
      let changed = false;

      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        if (!raw || raw.startsWith('#')) continue;

        const cols = splitConlluCols(raw);
        if (cols.length < 10) continue;

        const id = cols[0];
        if (id.includes('-') || id.includes('.')) continue; // skip non-word lines
        if (id !== tokenId) continue;

        while (cols.length < 10) cols.push('_'); // ensure 10 columns
        updater(cols); // modify columns in place
        lines[i] = cols.slice(0, 10).join('\t'); // write back as tabs
        changed = true;
        break;
      }

      if (changed) {
        const newTree = lines.join('\n');
        trees[currentIndex] = newTree;
        $('#treeBox').val(newTree);
        renderPosGrid();
      }
      return changed;
    }
	
	
	// Batch-edit the current tree by visiting each token row (10 columns).
	// updater(cols) may mutate cols in place; return true if changed for that row.
	function batchUpdateTree(updater) {
	  if (currentIndex < 0) return false;
	  const lines = (trees[currentIndex] || '').split('\n');
	  let anyChanged = false;

	  for (let i = 0; i < lines.length; i++) {
		const raw = lines[i];
		if (!raw || raw.startsWith('#')) continue;
		const cols = splitConlluCols(raw);
		if (cols.length < 10) continue;
		const id = cols[0];
		if (id.includes('-') || id.includes('.')) continue; // skip MWT/empty

		while (cols.length < 10) cols.push('_');
		const changed = updater(cols) === true;
		if (changed) {
		  lines[i] = cols.slice(0, 10).join('\t');
		  anyChanged = true;
		}
	  }

	  if (anyChanged) {
		const newTree = lines.join('\n');
		trees[currentIndex] = newTree;
		$('#treeBox').val(newTree);
		renderPosGrid();
	  }
	  return anyChanged;
	}

	// Convenience: read all token objects for the current tree (indexed by id)
	function getCurrentTokens() {
	  const tokens = parseTreeToTokens(trees[currentIndex] || '');
	  const byId = new Map(tokens.map(t => [t.id, t]));
	  return { tokens, byId };
	}
    // Debounced re-render when user edits the textbox
    function scheduleReparseAndRender() {
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        saveCurrentEdits();
        // keep selection only if the ID still exists
        const tokens = parseTreeToTokens(trees[currentIndex]);
        if (!tokens.some(t => t.id === selectedTokenId)) {
          selectedTokenId = null;
        }
        renderPosGrid();
		renderDependencySummary();
      }, 250);
    }

	// Get the tokens of the current tree (parsed)
	function getCurrentTokens() {
	  if (currentIndex < 0 || currentIndex >= trees.length) return [];
	  return parseTreeToTokens(trees[currentIndex]);
	}

	// Set B's head and deprel in one go, then refresh
	function setHeadAndDep(tokenId, headId, deprel) {
	  updateTokenById(tokenId, cols => {
		cols[6] = String(headId); // HEAD
		cols[7] = deprel;         // DEPREL
	  });
	}

	// Find any existing subject of headId (nsubj/csubj), return their IDs
	function findSubjectsOf(headId) {
	  const toks = getCurrentTokens();
	  const hid = String(headId);
	  return toks.filter(t => t.head === hid && /^(nsubj|csubj)$/i.test(t.deprel || ''));
	}

	// Heuristic: is B a non-finite verb (look for a 'to' dependent)
	function isNonFiniteVerb(bTok, allToks) {
	  if (!bTok || (bTok.upos || '').toUpperCase() !== 'VERB') return false;
	  // If FEATS suggests infinitive/participle, treat as non-finite
	  if ((bTok.feats || '').match(/\bVerbForm=(Inf|Part|Ger)\b/i)) return true;
	  // Otherwise, look for a dependent 'to' with XPOS=TO or form 'to'
	  const bid = String(bTok.id);
	  return allToks.some(t =>
		t.head === bid &&
		(
		  (t.xpos || '').toUpperCase() === 'TO' ||
		  (t.form || '').toLowerCase() === 'to'
		)
	  );
	}

	// Execute an action for A(sourceId) and B(targetId)
	function performTwoStepAction(type, sourceId, targetId) {
	  const toks = getCurrentTokens();
	  const A = toks.find(t => t.id === String(sourceId));
	  const B = toks.find(t => t.id === String(targetId));
	  if (!A || !B) return;

	  if (type === 'b') {
		// 1) Make B the subject of A.
		// Demote any current subject(s) of A to 'fmrsubj'
		const subs = findSubjectsOf(A.id);
		for (const s of subs) {
		  setHeadAndDep(s.id, A.id, 'fmrsubj');
		}
		// If B is a VERB => csubj, else nsubj
		const isVerbB = (B.upos || '').toUpperCase() === 'VERB';
		const newDep = isVerbB ? 'csubj' : 'nsubj';
		setHeadAndDep(B.id, A.id, newDep);
		$('#status').text(`Set token ${B.id} as ${newDep} of ${A.id}; demoted ${subs.length} subject(s) to fmrsubj`);
	  } else if (type === 'c') {
		// 2) Set B as A's complement based on B's properties:
		// - dobj if B is NOUN
		// - xcomp if B is a nonfinite VERB (heuristic with 'to')
		// - CCOMP if B is a finite verb (elsewhere)
		const up = (B.upos || '').toUpperCase();
		let dep;
		if (up === 'NOUN' || up === 'PROPN' || up === 'PRON') {
		  dep = 'dobj';
		} else if (up === 'VERB') {
		  dep = isNonFiniteVerb(B, toks) ? 'xcomp' : 'CCOMP';
		} else {
		  // fallback: treat non-noun non-verb as obj
		  dep = 'dobj';
		}
		setHeadAndDep(B.id, A.id, dep);
		$('#status').text(`Set token ${B.id} as ${dep} of ${A.id}`);
	  } else if (type === 'p') {
		// 3) B's dependency DISCOURSE with A as head
		setHeadAndDep(B.id, A.id, 'DISCOURSE');
		$('#status').text(`Set token ${B.id} as DISCOURSE of ${A.id}`);
	  } else if (type === 't') {
		// 4) B's dependency dislocated with A as head
		setHeadAndDep(B.id, A.id, 'dislocated');
		$('#status').text(`Set token ${B.id} as dislocated of ${A.id}`);
	  } else if (type === 'x') {
		// 5) B's dependency parataxis with A as head
		setHeadAndDep(B.id, A.id, 'parataxis');
		$('#status').text(`Set token ${B.id} as parataxis of ${A.id}`);
	  }

	  // Clear pending action and update selection to B (optional)
	  pendingAction = null;
	  selectedTokenId = String(B.id);
	  renderPosGrid();
	  
	  // Only update selection outside mass edit
	  if (!massEditActive) {
		selectedTokenId = sourceId;
		renderPosGrid();
	  } else {
		// In mass edit we already re-render and keep w1 highlighted in the click handler
	  }
	}


	function enterMassEdit() {
	  massEditActive  = true;
	  massAnchorId    = null;
	  massPendingKind = null;
	  // Cancel other pending states
	  pendingTwoStep = null;
	  pendingMerge   = null;
	  $('#status').text('Mass edit: on. Click a word (w1), press b/c/p/t/x, then click a target (w2). Escape: clear; Escape again: exit.');
	}

	function clearMassEditPending() {
	  massAnchorId    = null;
	  massPendingKind = null;
	  $('#status').text('Mass edit: on (idle). Click a word (w1), then press b/c/p/t/x.');
	}

	function exitMassEdit() {
	  massEditActive  = false;
	  massAnchorId    = null;
	  massPendingKind = null;
	  $('#status').text('Mass edit: off.');
	}
	
    // Export all trees as a .conllu file
    function exportAllTrees() {
      if (!trees.length) return;
      saveCurrentEdits();
      const content = trees.join('\n\n') + '\n';
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const a = document.createElement('a');
      const base = (originalFileName || 'trees.conllu').replace(/\.[^.]+$/, '');
      a.href = URL.createObjectURL(blob);
      a.download = `${base}-edited.conllu`;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(a.href);
      a.remove();
      $('#status').text(`Exported ${trees.length} tree(s) to ${base}-edited.conllu`);
    }

    // Utility: are we typing (focus inside input/textarea/contenteditable)?
    function isTypingTarget(el) {
      if (!el) return false;
      const $el = $(el);
      if ($el.is('input, textarea')) return true;
      if ($el.is('[contenteditable=""], [contenteditable="true"]')) return true;
      return false;
    }

    // Apply requested keyboard edits to the selected token
    function handleEditKey(key) {
      if (!selectedTokenId) return;
      const k = key.toLowerCase();

      if (k === 'r') {
		  // Re-root: old root -> deprel="sth", head=selected; selected -> root with head=0
		  rerootTree(selectedTokenId, 'sth');
		  return;
	  } else if (k === 'v') {
        updateTokenById(selectedTokenId, cols => { cols[3] = 'VERB'; });
      } else if (k === 'n') {
        updateTokenById(selectedTokenId, cols => { cols[3] = 'NOUN'; });
      } else if (k === 'a') {
        updateTokenById(selectedTokenId, cols => { cols[3] = 'ADV'; });
      } else if (k === 'i') {
        updateTokenById(selectedTokenId, cols => { cols[3] = 'INTJ'; });
      }
    }
	console.log('Helpers loaded OK');
	// Re-root the tree on the given token ID.
	// formerRootDeprel is what the old root becomes (default: "sth").
	function rerootTree(selectedId, formerRootDeprel = 'sth') {
	  if (currentIndex < 0 || !trees.length || !selectedId) return;

	  const treeText = trees[currentIndex] || '';
	  const lines = treeText.split('\n');

	  let selIdx = -1, rootIdx = -1;
	  let selCols = null, rootCols = null;

	  // Locate selected token line and current root line
	  for (let i = 0; i < lines.length; i++) {
		const raw = lines[i];
		if (!raw || raw.startsWith('#')) continue;

		const cols = splitConlluCols(raw);
		if (cols.length < 10) continue;

		const id = cols[0];
		if (id.includes('-') || id.includes('.')) continue; // skip MWT/empty nodes

		const deprel = (cols[7] || '').toLowerCase();
		if (id === selectedId) {
		  selIdx = i;
		  selCols = cols;
		}
		if (deprel === 'root') {
		  // Take the first root we find; UD should have exactly one
		  if (rootIdx === -1) {
			rootIdx = i;
			rootCols = cols;
		  }
		}
	  }

	  // Nothing to do if selected not found
	  if (selIdx === -1 || !selCols) return;

	  // If selected is already root, no change
	  const selIsRoot = (selCols[7] || '').toLowerCase() === 'root';
	  if (selIsRoot && (selCols[6] === '0' || selCols[6] === 0)) {
		$('#status').text(`Token ${selectedId} is already root`);
		return;
	  }

	  // Update former root if present and not the same as selected
	  if (rootIdx !== -1 && rootIdx !== selIdx && rootCols) {
		rootCols[6] = String(selectedId);    // HEAD = selected token
		rootCols[7] = formerRootDeprel;      // DEPREL = "sth" (or your chosen label)
		lines[rootIdx] = rootCols.slice(0, 10).join('\t');
	  }

	  // Set selected token as new root
	  selCols[6] = '0';            // HEAD=0
	  selCols[7] = 'root';         // DEPREL=root
	  lines[selIdx] = selCols.slice(0, 10).join('\t');

	  // Write back
	  const newTree = lines.join('\n');
	  trees[currentIndex] = newTree;
	  $('#treeBox').val(newTree);
	  renderPosGrid();
	  $('#status').text(`Re-rooted on token ${selectedId}`);
	}
	
	// Build index maps and children lists from the current tree tokens
	function buildHeadChildren(tokens) {
	  const byId = new Map(tokens.map(t => [t.id, t]));
	  const children = new Map(); // headId -> array of child tokens
	  for (const t of tokens) {
		const headId = t.head;
		if (!children.has(headId)) children.set(headId, []);
		children.get(headId).push(t);
	  }
	  return { byId, children };
	}

	function findFirstChildWithDep(childrenMap, headId, depLabels) {
	  const kids = childrenMap.get(headId) || [];
	  const wanted = (Array.isArray(depLabels) ? depLabels : [depLabels]).map(d => d.toLowerCase());
	  for (const k of kids) {
		const d = (k.deprel || '').toLowerCase();
		if (wanted.includes(d)) return k;
	  }
	  return null;
	}

	function hasChildWithDep(childrenMap, headId, depRegex) {
	  const kids = childrenMap.get(headId) || [];
	  for (const k of kids) {
		const d = (k.deprel || '');
		if (depRegex.test(d)) return true;
	  }
	  return false;
	}

	function isVerbTok(tok) {
	  return tok && (tok.upos || '').toUpperCase() === 'VERB';
	}
	function isNounTok(tok) {
	  const up = (tok.upos || '').toUpperCase();
	  return up === 'NOUN' || up === 'PROPN';
	}
	function isPronTok(tok) {
	  return (tok.upos || '').toUpperCase() === 'PRON';
	}
	
    function isRootTok(t) {
	  return (t.deprel || '').toLowerCase() === 'root';
	}

	// Check if a head has any child whose deprel matches ANY of the given regex patterns
	function hasChildWithDeps(childrenMap, headId, depPatterns) {
	  const kids = childrenMap.get(headId) || [];
	  return kids.some(k => depPatterns.some(re => re.test(k.deprel || '')));
	}
	
	// Complement labels (case-insensitive): obj/dobj, xcomp, ccomp/CCOMP
	function findComplement(childrenMap, headId) {
	  const kids = childrenMap.get(headId) || [];
	  // Prefer dobj/obj, then xcomp, then ccomp/CCOMP
	  const order = [
		/^(obj|dobj)$/i,
		/^xcomp$/i,
		/^ccomp$/i,
		/^CCOMP$/i
	  ];
	  for (const re of order) {
		const found = kids.find(k => re.test(k.deprel || ''));
		if (found) return found;
	  }
	  return null;
	}

	// Particles: include UD compound:prt and discourse/ DISCOURSE
	function findParticles(childrenMap, headId) {
	  const kids = childrenMap.get(headId) || [];
	  return kids.filter(k => /^(compound:prt|discourse|DISCOURSE)$/i.test(k.deprel || ''));
	}

	// Position helper: show token ID (and before/after relative to head)
	function positionLabel(headTok, depTok) {
	  try {
		const h = parseInt(headTok.id, 10);
		const d = parseInt(depTok.id, 10);
		if (!isFinite(h) || !isFinite(d)) return String(depTok.id);
		const rel = d < h ? 'before' : (d > h ? 'after' : 'same');
		return `[${depTok.id}, ${rel}]`;
	  } catch {
		return String(depTok.id);
	  }
	}
	
	function renderDependencySummary() {
	  const container = $('#depSummary');
	  container.empty();

	  if (currentIndex < 0 || currentIndex >= trees.length) return;

	  const tokens = parseTreeToTokens(trees[currentIndex]);
	  if (!tokens.length) return;

	  // Build maps
	  const byId = new Map(tokens.map(t => [t.id, t]));
	  const children = new Map();
	  for (const t of tokens) {
		if (!children.has(t.head)) children.set(t.head, []);
		children.get(t.head).push(t);
	  }

	  // Helpers
	  const kidsOf = (id) => children.get(id) || [];
	  const one = (id, reArr) => kidsOf(id).find(k => reArr.some(re => re.test(k.deprel || ''))) || null;
	  const many = (id, reArr) => kidsOf(id).filter(k => reArr.some(re => re.test(k.deprel || '')));
	  const isVerb = (t) => (t.upos || '').toUpperCase() === 'VERB';
	  const posLabel = (head, dep) => {
		const h = parseInt(head.id, 10), d = parseInt(dep.id, 10);
		if (isFinite(h) && isFinite(d)) return `${dep.id} (${d < h ? 'before' : (d > h ? 'after' : 'same')})`;
		return String(dep.id);
	  };

	  // Only VERBs are listed (as requested)
	  const verbs = tokens.filter(isVerb);
	  if (!verbs.length) return;

	  const $ul = $('<ul/>');

	  for (const v of verbs) {
		const headLabel = `${v.form || ''} [${v.id}] VERB`;
		const $liHead = $('<li/>', { class: 'verb-head', text: headLabel });
		const $sub = $('<ul/>');

		// Subject (must indicate presence/absence)
		const subj = one(v.id, [/^csubj$/i, /^nsubj$/i]) || one(v.id, [/^nsubj$/i, /^csubj$/i]);
		if (subj) {
		  $sub.append($('<li/>').text(`subject: ${subj.form} ${posLabel(v, subj)} (${subj.deprel})`));
		} else {
		  $sub.append($('<li/>', { class: 'nil', text: 'subject: nil' }));
		}

		// Complement (optional): obj/dobj, xcomp, ccomp/CCOMP
		const comp = one(v.id, [/^(obj|dobj)$/i, /^xcomp$/i, /^ccomp$/i, /^CCOMP$/i]);
		if (comp) {
		  $sub.append($('<li/>').text(`complement: ${comp.form} ${posLabel(v, comp)} (${comp.deprel})`));
		}

		// Particles (optional): compound:prt and discourse/DISCOURSE
		const particles = many(v.id, [/^compound:prt$/i, /^discourse$/i, /^DISCOURSE$/i]);
		if (particles.length) {
		  const labels = particles.map(p => `${p.form} ${posLabel(v, p)} (${p.deprel})`).join(', ');
		  $sub.append($('<li/>').text(`particles: ${labels}`));
		}

		// Topic (optional): dislocated and topic (if your data uses 'topic')
		const topicKids = many(v.id, [/^dislocated$/i, /^topic$/i]);
		if (topicKids.length) {
		  const labels = topicKids.map(tk => `${tk.form} ${posLabel(v, tk)} (${tk.deprel})`).join(', ');
		  $sub.append($('<li/>').text(`topic: ${labels}`));
		}

		// Parataxis (optional)
		const paraKids = many(v.id, [/^parataxis$/i]);
		if (paraKids.length) {
		  const labels = paraKids.map(pk => `${pk.form} ${posLabel(v, pk)} (${pk.deprel})`).join(', ');
		  $sub.append($('<li/>').text(`parataxis: ${labels}`));
		}

		// Auxiliaries / Copulas (optional)
		const auxKids = many(v.id, [/^aux$/i]);
		const copKids = many(v.id, [/^cop$/i]);
		if (auxKids.length) {
		  const labels = auxKids.map(a => `${a.form} ${posLabel(v, a)} (aux)`).join(', ');
		  $sub.append($('<li/>').text(`auxiliaries: ${labels}`));
		}
		if (copKids.length) {
		  const labels = copKids.map(c => `${c.form} ${posLabel(v, c)} (cop)`).join(', ');
		  $sub.append($('<li/>').text(`copulas: ${labels}`));
		}

		$liHead.append($sub);
		$ul.append($liHead);
	  }

	  container.append($ul);
	}

	function showSplitUI(prefill = '') {
	  splitInputActive = true;
	  $('#splitInput').val(prefill).show().focus();
	  $('#splitApplyBtn').show();
	  $('#status').text('Type space-separated words, then press Enter or click Apply split.');
	}
	function hideSplitUI() {
	  splitInputActive = false;
	  $('#splitInput').hide();
	  $('#splitApplyBtn').hide();
	}

	// Split input UI events
	$('#splitApplyBtn').on('click', function() {
	  applySplitOnSelected();
	});
	$('#splitInput').on('keydown', function(e) {
	  if (e.key === 'Enter') {
		e.preventDefault();
		applySplitOnSelected();
	  } else if (e.key === 'Escape') {
		hideSplitUI();
		$('#status').text('Split cancelled.');
	  }
	});
	
    // Handlers
    $(function() {
      $('#fileInput').on('change', function(e) {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        originalFileName = file.name || 'trees.conllu';

        const reader = new FileReader();
        reader.onload = function(ev) {
          const text = ev.target.result || '';
          trees = parseConllu(text);
          selectedTokenId = null;

          if (trees.length === 0) {
            $('#fileInfo').text(`${file.name} — parsed 0 trees`);
            currentIndex = -1;
            renderCurrentTree();
            return;
          }

          currentIndex = 0;
          $('#fileInfo').text(`${file.name} — parsed ${trees.length} trees`);
          renderCurrentTree();
        };
        reader.readAsText(file);
      });

      $('#prevBtn').on('click', function() {
        saveCurrentEdits();
        if (currentIndex > 0) {
          currentIndex -= 1;
          selectedTokenId = null;
          renderCurrentTree();
        }
      });

      $('#nextBtn').on('click', function() {
        saveCurrentEdits();
        if (currentIndex < trees.length - 1) {
          currentIndex += 1;
          selectedTokenId = null;
          renderCurrentTree();
        }
      });

      $('#treeBox').on('input', scheduleReparseAndRender);
	  
		// Help panel toggle
		$('#helpToggleBtn').on('click', function() {
		  const panel = $('#helpPanel');
		  const isHidden = panel.hasClass('hidden');
		  panel.toggleClass('hidden', !isHidden);
		  $('#helpToggleBtn').text(isHidden ? 'Hide Help' : 'Show Help');
		});

		// UD tree show/hide toggle
		$('#treeToggleBtn').on('click', function() {
		  const box = $('#treeBox');
		  const isHidden = box.css('display') === 'none';
		  if (isHidden) {
			box.show();
			$('#treeToggleBtn').text('Hide UD Tree');
		  } else {
			box.hide();
			$('#treeToggleBtn').text('Show UD Tree');
		  }
		});

		// Ensure the button reflects initial default (tree hidden by CSS)
		$('#treeToggleBtn').text('Show UD Tree');
		$('#helpToggleBtn').text('Show Help'); // start hidden by default

	function isRootTok(t) {
	  return (t.deprel || '').toLowerCase() === 'root';
	}

	// Check if a head has any child whose deprel matches ANY of the given regex patterns
	function hasChildWithDeps(childrenMap, headId, depPatterns) {
	  const kids = childrenMap.get(headId) || [];
	  return kids.some(k => depPatterns.some(re => re.test(k.deprel || '')));
	}
	
	// Keyboard shortcuts: navigation, export, single-token edits, and two-step actions.
	// Disabled while typing.
	// COMPLETE keydown handler (drop-in). Covers:
// - Guided Edit (batch) mode: g to start; b/c/p/t/x choose relation; Enter confirm proposal; Esc advance; Shift+6 (^) terminate
// - Guided Edit (panel) mode: g while a token is selected (if you use the panel variant)
// - Mass Edit mode: m to start; b/c/p/t/x then click; Esc clear/exit
// - Navigation < >, export Shift+S, single-token edits r/v/n/a/p, split '-', merge '+'
// Shortcuts disabled while typing or split input is active.
$(document).on('keydown', function(e) {
  if (isTypingTarget(e.target) || splitInputActive) return;
  if (currentIndex < 0) return;

  const key  = e.key;
  const code = e.code;

  // =========================
  // Guided Edit (batch) MODE
  // =========================

  // Terminate Guided Edit (batch) with Shift+6 (^)
  if ((key === '^') || (code === 'Digit6' && e.shiftKey)) {
    if (guidedBatchActive) {
      e.preventDefault();
      guidedBatchActive = false;
      guidedOp = null;
      guidedW1List = [];
      guidedW1Idx = -1;
      guidedCandidateId = null;
      guidedMultiSelect = false;
      $('#status').text('Guided (batch): terminated.');
      renderPosGrid();
    }
    return;
  }

  // Start Guided Edit (batch) with 'g' (no preselection required)
  if (key.toLowerCase() === 'g' && !guidedEditActive) {
    e.preventDefault();
    guidedBatchActive = true;
    guidedOp = null;               // wait for b/c/p/t/x
    guidedW1List = buildGuidedW1List();
    guidedW1Idx = -1;
    guidedCandidateId = null;
    guidedMultiSelect = false;
    if (!guidedW1List.length) {
      $('#status').text('Guided (batch): no eligible w1 (root/xcomp/ccomp/parataxis) in this tree.');
    } else {
      $('#status').text('Guided (batch): active. Press b/c/p/t/x to choose relation.');
    }
    renderPosGrid();
    return;
  }

  // If Guided Edit (batch) is active, it takes priority over other shortcuts
  if (guidedBatchActive) {
    // Choose relation type: b/c/p/t/x
    if (['b','B','c','C','p','P','t','T','x','X'].includes(key)) {
      e.preventDefault();
      startGuidedOp(key.toLowerCase());  // sets guidedOp and calls advanceGuidedToNextW1()
      return;
    }

    // Confirm proposed dependent for current w1 (Enter)
    if (key === 'Enter') {
      e.preventDefault();
      const w1Id = currentGuidedW1Id && currentGuidedW1Id();
      if (!w1Id || !guidedOp) return;

      if (guidedCandidateId) {
        performTwoStepAction(guidedOp, w1Id, guidedCandidateId);
        renderPosGrid();
        if (typeof renderDependencySummary === 'function') renderDependencySummary();

        if (guidedOp === 'b') {
          guidedCandidateId = null;
          advanceGuidedToNextW1();
        } else {
          guidedCandidateId = null;
          $('#status').text('Guided (batch): confirmed one. Click other applicable words or press Esc when done.');
        }
      } else {
        $('#status').text('Guided (batch): no proposed dependent to confirm. Click a word or press Esc.');
      }
      return;
    }

    // Finish current w1 (no more targets) and move to next (Escape)
    if (key === 'Escape') {
      e.preventDefault();
      if (!guidedOp) {
        // No op chosen yet: exit guided mode
        guidedBatchActive = false;
        $('#status').text('Guided (batch): exited.');
        renderPosGrid();
        return;
      }
      guidedCandidateId = null;
      advanceGuidedToNextW1();  // auto-advances tree when done
      return;
    }

    // While guided mode is active, suppress other shortcuts
    return;
  }

  // ==============================
  // Guided Edit (panel) VARIANT
  // ==============================
  // If you use the interactive panel mode (guidedEditActive), keep its keys separate.
  if (guidedEditActive) {
    if (key === 'Escape') {
      e.preventDefault();
      if (guidedPendingKind || guidedAwaitKey) {
        guidedPendingKind = null;
        guidedAwaitKey    = false;
        guidedPendingW2   = null;
        updateGuidedHint && updateGuidedHint();
        renderPosGrid();
      } else {
        exitGuided();
      }
      return;
    }
    if (['b','B','c','C','p','P','t','T','x','X'].includes(key)) {
      e.preventDefault();
      if (!guidedAnchorId) {
        $('#status').text('Guided Edit: click an anchor word first.');
        return;
      }
      guidedPendingKind = key.toLowerCase();
      guidedAwaitKey    = false;
      guidedPendingW2   = null;
      updateGuidedHint && updateGuidedHint();
      applyGuidedSuggestions && applyGuidedSuggestions(parseTreeToTokens(trees[currentIndex] || ''));
      return;
    }
    // Suppress other shortcuts while panel-guided mode is active
    return;
  }

  // =====================
  // Navigation / Export
  // =====================
  if (key === '<' || (code === 'Comma' && e.shiftKey)) {
    e.preventDefault();
    $('#prevBtn').click();
    return;
  }
  if (key === '>' || (code === 'Period' && e.shiftKey)) {
    e.preventDefault();
    $('#nextBtn').click();
    return;
  }
  if (e.shiftKey && (key === 'S' || key === 's')) {
    e.preventDefault();
    exportAllTrees();
    return;
  }

  // ==============
  // Mass Edit mode
  // ==============
  if (key.toLowerCase() === 'm') {
    e.preventDefault();
    if (!massEditActive) enterMassEdit();
    else clearMassEditPending();
    return;
  }
  if (massEditActive) {
    if (key === 'Escape') {
      e.preventDefault();
      if (massPendingKind || massAnchorId) clearMassEditPending();
      else exitMassEdit();
      return;
    }
    if (['b','B','c','C','p','P','t','T','x','X'].includes(key)) {
      e.preventDefault();
      if (!massAnchorId) {
        $('#status').text('Mass edit: click w1 first, then press b/c/p/t/x.');
        return;
      }
      massPendingKind = key.toLowerCase();
      $('#status').text(`Mass edit: '${massPendingKind}' pending from w1=${massAnchorId}. Click w2.`);
      return;
    }
    // While mass edit is active, skip other shortcuts
    return;
  }

  // ==================
  // Split / Merge ops
  // ==================
  if (key === '-' || code === 'Minus') {
    e.preventDefault();
    if (!selectedTokenId) {
      $('#status').text('Select a token first, then press - to split.');
      return;
    }
    const toks = parseTreeToTokens(trees[currentIndex]);
    const selTok = toks.find(t => t.id === selectedTokenId);
    showSplitUI(selTok ? selTok.form : '');
    return;
  }
  if (key === '+' || code === 'Equal') {
    e.preventDefault();
    if (!selectedTokenId) {
      $('#status').text('Select token A first, then press + and click adjacent token B.');
      return;
    }
    startMerge();
    return;
  }

  // ============================
  // Single-token edit shortcuts
  // ============================
  if (['r','R','v','V','n','N','a','A','p','P'].includes(key)) {
    e.preventDefault();
    pendingTwoStep = null; anchorTokenId = null; pendingMerge = null;
    if (!selectedTokenId) { $('#status').text('Select a token first.'); return; }
    if (key.toLowerCase() === 'r') rerootTree(selectedTokenId, 'sth');
    else handleEditKey(key);
    return;
  }

  // =====================
  // Two-step (non-mass)
  // =====================
  if (['b','B','c','C','p','P','t','T','x','X'].includes(key)) {
    if (!selectedTokenId) { $('#status').text('Select token A first, then press b/c/p/t/x.'); return; }
    e.preventDefault();
    pendingTwoStep = key.toLowerCase();
    anchorTokenId  = selectedTokenId;
    $('#status').text(`Pending '${pendingTwoStep}' from A=${anchorTokenId}. Now click B.`);
    return;
  }
}); // END keydown handler
	}); // END of $(function(){ ... })
	
	// Guided Edit mode
	// Collect tokens that are dependents of root/xcomp/ccomp/parataxis
	// Guided batch: collect all w1 candidates in the current tree:
	// - any VERB
	// - any token with deprel=root
	// - any token that HEADS at least one child with deprel in {ccomp, xcomp, parataxis}
	function buildGuidedW1List() {
	  const tokens = parseTreeToTokens(trees[currentIndex] || '');
	  const { children } = buildChildrenIndex(tokens);

	  const isVerb = (t) => (t.upos || '').toUpperCase() === 'VERB';
	  const isRoot = (t) => (t.deprel || '').toLowerCase() === 'root';
	  const headsClause = (t) => {
		const kids = children.get(t.id) || [];
		return kids.some(k => /^(ccomp|xcomp|parataxis|advcl|acl(:relcl)?)$/i.test(k.deprel || ''));
	  };

	  // Collect IDs, de-duplicate, sort numerically by token position
	  const ids = new Set();
	  tokens.forEach(t => {
		if (isVerb(t) || isRoot(t) || headsClause(t)) ids.add(t.id);
	  });

	  return Array.from(ids)
		.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
	}

	// Children index helpers
	function buildChildrenIndex(tokens) {
	  const byId = new Map(tokens.map(t => [t.id, t]));
	  const children = new Map();
	  for (const t of tokens) {
		if (!children.has(t.head)) children.set(t.head, []);
		children.get(t.head).push(t);
	  }
	  return { byId, children };
	}
	function findFirstChild(children, headId, depRegexes) {
	  const kids = children.get(headId) || [];
	  return kids.find(k => depRegexes.some(re => re.test(k.deprel || ''))) || null;
	}
	function findAllChildren(children, headId, depRegexes) {
	  const kids = children.get(headId) || [];
	  return kids.filter(k => depRegexes.some(re => re.test(k.deprel || '')));
	}

	// Proposed existing dependent (per guidedOp)
	function proposeExistingDependent(w1, guidedOp) {
	  const tokens = parseTreeToTokens(trees[currentIndex] || '');
	  const { children } = buildChildrenIndex(tokens);

	  if (guidedOp === 'b') {
		// subject: prefer csubj then nsubj (or vice-versa; pick first found)
		return findFirstChild(children, w1, [/^csubj$/i, /^nsubj$/i]) ||
			   findFirstChild(children, w1, [/^nsubj$/i, /^csubj$/i]);
	  }
	  if (guidedOp === 'c') {
		// complements: obj/dobj, xcomp, ccomp/CCOMP
		return findFirstChild(children, w1, [/^(obj|dobj)$/i, /^xcomp$/i, /^ccomp$/i, /^CCOMP$/i]);
	  }
	  if (guidedOp === 'p') {
		return findFirstChild(children, w1, [/^discourse$/i, /^DISCOURSE$/i]);
	  }
	  if (guidedOp === 't') {
		return findFirstChild(children, w1, [/^dislocated$/i, /^topic$/i]);
	  }
	  if (guidedOp === 'x') {
		return findFirstChild(children, w1, [/^parataxis$/i]);
	  }
	  return null;
	}

	// Status prompt helpers
	function promptForW1(w1Id) {
	  const toks = parseTreeToTokens(trees[currentIndex] || '');
	  const t = toks.find(z => z.id === w1Id);
	  const headStr = t ? `${t.form} [${t.id}]` : `ID ${w1Id}`;
	  const roleMap = { b: 'subject', c: 'complements', p: 'DISCOURSE particles', t: 'topic/dislocated', x: 'parataxis' };
	  if (guidedOp === 'b') {
		if (guidedCandidateId) {
		  const cand = toks.find(z => z.id === guidedCandidateId);
		  const cstr = cand ? `${cand.form} [${cand.id}]` : `ID ${guidedCandidateId}`;
		  $('#status').text(`Guided (subject): w1=${headStr}. Is “${cstr}” the subject? Enter=Yes, click another word to set; Esc=NIL`);
		} else {
		  $('#status').text(`Guided (subject): w1=${headStr}. Click the subject (or Esc for NIL).`);
		}
	  } else {
		const role = roleMap[guidedOp] || guidedOp;
		if (guidedCandidateId) {
		  const cand = toks.find(z => z.id === guidedCandidateId);
		  const cstr = cand ? `${cand.form} [${cand.id}]` : `ID ${guidedCandidateId}`;
		  $('#status').text(`Guided (${role}): w1=${headStr}. Confirm “${cstr}” (Enter) or click correct one(s). Esc=done for this w1.`);
		} else {
		  $('#status').text(`Guided (${role}): w1=${headStr}. Click all applicable word(s). Esc=done for this w1.`);
		}
	  }
	}

	// Start guided batch on a relation letter
	function startGuidedOp(opLetter) {
	  if (currentIndex < 0) return;
	  guidedBatchActive = true;
	  guidedOp = opLetter.toLowerCase();
	  guidedW1List = buildGuidedW1List();
	  guidedW1Idx = -1;
	  guidedCandidateId = null;
	  guidedMultiSelect = (guidedOp !== 'b'); // only 'b' is single; others allow multiple
	  if (!guidedW1List.length) {
		$('#status').text('Guided: no eligible w1 (root/xcomp/ccomp/parataxis) in this tree.');
		return;
	  }
	  advanceGuidedToNextW1();
	}

	// Utility: current w1 id (or null)
	function currentGuidedW1Id() {
	  return (guidedW1Idx >= 0 && guidedW1Idx < guidedW1List.length) ? guidedW1List[guidedW1Idx] : null;
	}

	// Move to the next w1 for guided batch editing.
	// If finished in this tree, auto-advance to the next tree and continue the same operation.
	function advanceGuidedToNextW1() {
	  if (!guidedBatchActive || !guidedOp) {
		$('#status').text('Guided: not active.');
		return;
	  }
	  if (currentIndex < 0 || currentIndex >= trees.length) {
		$('#status').text('Guided: no tree loaded.');
		return;
	  }

	  // Advance index
	  guidedW1Idx += 1;

	  // If done with this sentence, auto-advance to the next tree
	  if (guidedW1Idx >= guidedW1List.length) {
		// Try to move to next tree
		if (currentIndex < trees.length - 1) {
		  // Save edits and go next
		  saveCurrentEdits && saveCurrentEdits();
		  $('#nextBtn').click();

		  // Recompute candidates for the new sentence
		  guidedW1List = buildGuidedW1List();
		  guidedW1Idx = -1;

		  if (!guidedW1List.length) {
			// No eligible w1 in this new sentence; recursively move further
			advanceGuidedToNextW1();
			return;
		  }
		  // Continue in the new sentence
		  advanceGuidedToNextW1();
		  return;
		} else {
		  // No more trees
		  $('#status').text('Guided: completed all sentences.');
		  guidedBatchActive = false;
		  guidedOp = null;
		  guidedCandidateId = null;
		  renderPosGrid && renderPosGrid();
		  return;
		}
	  }

	  // Set current w1 and propose a candidate dependent for this op
	  const w1Id = guidedW1List[guidedW1Idx];
	  guidedCandidateId = null;                 // reset candidate
	  guidedMultiSelect = (guidedOp !== 'b');   // only subject is single

	  // Propose an existing dependent (if any) for the prompt
	  const proposed = proposeExistingDependent(w1Id, guidedOp);
	  if (proposed) guidedCandidateId = proposed.id;

	  // Highlight w1 and update prompt
	  // If your grid highlights selectedTokenId, reuse it here:
	  if (typeof selectedTokenId !== 'undefined') selectedTokenId = w1Id;

	  // Render + prompt
	  renderPosGrid && renderPosGrid();
	  promptForW1(w1Id);
	}
  </script>
</body>
</html>